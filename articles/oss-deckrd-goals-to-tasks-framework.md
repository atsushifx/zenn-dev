---
title: "deckrd: 「やりたい」を実装可能なタスクに変えるドキュメントフレームワーク"
emoji: "🧭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["deckrd", "SDD", "仕様書駆動開発"]
published: false
---

<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->

## はじめに

atsushifx です。
Agent Skills が話題だったので、自分もプロダクトを作ってみました。
作成したのが `deckrd` 。
もともとは`SDD`という、`GitHub`のイシューをコーディングするエージェントコマンドだったのですが、
ブラッシュアップしていくうちに、タスクリストを作成するフレームワークになりました。

プロダクト作成の考え方などが、読者の参考になれば幸いです。.
それでは、Enjoy!

## 1. なぜ「AIに任せた設計」は断片化してしまうのか

AI を活用した開発は、要件整理や実装の初速を大きく引き上げました。一方で、設計フェーズにおいては「成果物はあるが、設計として再利用できない」という問題が表面化しがちです。このセクションでは、その原因を段階的に整理します。

### 1.1 AI との対話は“思考の途中経過”として消費されやすい

多くの AI 活用はチャットベースで行われます。
この形式では、やり取りそのものはログとして残る者の。整理したドキュメントとして残りません。

このため:

- 何を前提としていたのか
- どの要求を満たすための判断だったのか
- なぜ別案を採用しなかったのか

といった情報が明示的に整理されないまま流れていきます。
結果として、対話ログは存在しても「設計資料」としては扱いづらい状態になります。

### 1.2 文脈が固定化されないことによるズレ

生成 AI は、与えられたプロンプトを元に一貫した答えを出します。
ただし、文脈を読んで答える機能はないため、すでに否定した答えを蒸し返すこともあります。
AI をそのまま使うと、次のような問題が発生します。

- セッションを変えると前提が微妙に変わる
- 別の人が同じテーマで対話すると結論が変わる
- 後から読み返しても設計意図が追えない

これは、**設計判断の根拠が暗黙知のまま残る**ことが原因です。

### 1.3 「仕様はあるが、意図がない」状態

AI によって生成された仕様やタスクは、一見すると十分に整理されているように見えます。しかし、その多くは「結果」だけです。

- なぜこの仕様になったのか
- どの要求から導かれたのか
- どこまでが前提条件なのか

といった情報が欠落しています。
この状態では、後から仕様変更や見直しを行う際に、判断の起点がわからず、設計を積み上げられません。

### 1.4 SDD などの AI 支援開発で起きがちな問題

SDD などの AI 支援開発手法を試した場合も、同様の課題が見られます。

- Issue やタスクは生成される
- しかし、それらの背景となる要求や設計判断が残らない
- タスク同士の関係性が見えなくなる

結果として、「タスクは増えるが全体像は見えない」という断片化が進行します。

### 1.5 問題は「AI」ではなく「扱い方」にある

ここまで見てきた問題は、AI の性能不足によるものではありません。
本質的な課題は、**AI との対話を設計資産として扱えていないこと**にあります。

要求・前提・判断・結論を一貫したドキュメントとして残せない限り、設計は何度でも分断されます。
この課題に対する 1つの答えとして提示されているのが、次のセクションで紹介する「Your Goals to Tasks」という考え方です。

## 2. `deckrd` が目指す「Your Goals to Tasks」という考え方

`deckrd` の中核にあるのは、「Your Goals to Tasks」というシンプルな考え方です。
これは、**やりたいこと (Goal) から出発し、それを実装可能なタスク (Tasks) まで一貫して導出する** ことを重視する姿勢を表しています。

### 2.1 多くの開発は「途中」から始まってしまう

AI 支援開発を含め、多くの開発現場では次のような始まり方をします。

- いきなり Issue やタスクを作る
- 仕様書の一部だけを書き始める
- 実装方法の相談から入る

これらは効率的に見えますが、「なぜそれを作るのか」「最終的に何を達成したいのか」という **Goal** が明文化されないまま進むことがほとんどです。その結果、途中で方向性が変わった際に、どこから見直すべきかわからなくなります。

### 2.2 Goal を起点にすると何が変わるのか

`deckrd` では、最初に **Goal を言語化する**ことを重視します。
Goal を起点にすることで、次の点が明確になります。

- 何を達成できれば成功なのか
- 今回は、何をやらないのか
- 判断に迷ったときの基準は何か

この状態を作ってから AI と対話することで、設計や仕様のブレを最小限に抑えられます。AI は単に指示に答える存在ではなく、**Goal を満たすための選択肢を整理するパートナー**として機能します。

### 2.3 Requirements → Specs → Implementations → Tasks という全体の流れ

`deckrd` における「Your Goals to Tasks」は、次のような段階的な流れとして整理されます。

- Requirements: Goal を満たすために必要な要求
- Specs: 要求を満たすための仕様
- Implementations: 仕様を実現するための実装方針
- Tasks: 実装・検証可能な作業単位

この流れは、単に段階的に分轄しているのではありません。
段階ごとに、何を決定して何を実現するのか、という視点の変更がポイントです。
すなわち、**思考の役割を段階ごとに分離する** ことが大事なのです。

Requirements では、「何が必要か」を定義します。
この段階では実装方法を考えず、満たすべき条件や制約を明確にします。

Specs では、「それをどういう形で満たすか」を整理します。
Requirements を具体的な振る舞いや構造として表現し、実装に依存しない仕様として固定します。

Implementations では、「その仕様をどう実現するか」を検討します。
ここでは、何を実現し、何と実現しないのかという実装のための判断基準を大まかに決めます。

Tasks では、それまでのドキュメントを元に、実際に実装するタスクを決めます。
特に重要なのは、タスクの単位、`deckrd`では Task をユニットテストでのテストケースまでと決めています。
これにより、タスクリスト自体が動作する仕様書となります。

この要件からタスクリストまでの一貫した流れ、そしてそれをドキュメントとして残すことによって、`deckrd`は、**設計の思考過程そのものをドキュメントとして残すフレームワーク**になります。

### 2.4 `deckrd` における Implementation とは何か

`deckrd` における Implementation は、コードを書くための詳細設計ではありません。
役割は、**Specs をどのように実現するか、あるいは実現しないかを決めること**にあります。

この層では、次のような内容を扱います。

- 採用する技術やアーキテクチャの方向性
- 代替案の比較と、その選択理由
- 制約条件や前提の整理

重要なのは、Implementation が **Tasks を作るための前提条件**として存在している点です。
Implementation を明示することで、以下を節目でいできるようになります。

- なぜこの Tasks 構成になったのか
- 実装方針が変わった場合、どこから見直すべきか

### 2.5 `decision records`で思考を記録する

`deckrd`では、ドキュメントは AI が作成して終わりではありません。
最初に AI が作成したドキュメントをたたき台にして、さらに議論する。
AI エージェントにドキュメントをレビューしてもらって手直しをする。
こういった形でドキュメントを完成に持っていきます。

いわゆるウォーターフォールのように、全体の流れが一方向というわけでもありません。
Specification フェーズや Implementation フェーズで、問題がみつかれば前のフェーズへの手戻りもありえます。

こういった嗜好の変化は記録しないと残りません。
`deckrd`では DR (`decision records`)にこれらを記録することで、ドキュメントのトレーサビリティを確保しています。

### 2.6 `deckrd`におけるAIとの対話

`deckrd`では、要件定義書や仕様書などの成果物は単なるドキュメントではありません。
ドキュメントをとうして、問題点をユーザーと AI で共有し解決するための装置、'Problem vs Us'の構図を作るための装置です。

AI との対話も、単に成果物を完成させるための質問ではありません。

- Requirements フェーズでは、Goal からどの要求を要件とすべきかを判断する
- Specs フェーズでは、要求の抜けや曖昧さを整理し、実現可能な仕様へと落としこむ
- Implementation フェーズでは、実際の仕様から現実的な実装にするための方針を決める
- Tasks フェーズでは、タスクの粒度や責務を確認する

こういった、自分の思考を深めるための装置なのです。

重要なのは、AI との対話そのものではなく、**その結果として残るドキュメント**です。
仕様書などの成果物や`DecisionRecords`によって嗜好を終えることが重要なのです。

### 2.7 `deckrd`はタスク作成ツールではない

`deckrd` は Tasks を生成しますが、タスク作成ツールではありません。
本質は、**Goal から Tasks に至る思考と判断を、一貫したドキュメントとして残すこと**にあります。

- Tasks は必ず Requirements / Specs / Implementations に裏付けられている
- Tasks から逆に辿れば、Goal まで説明できる
- 実装や技術が変わっても、設計は再利用できる

この構造によって、`deckrd` は「その場限りで終わる AI 開発」ではなく、**速く、かつ積み上げられる開発**を可能にします。

次のセクションでは、この考え方をどのように具体的な仕組みとして実現しているのか、AI との対話を“ドキュメント”として固定化する方法を見ていきます。

## 3. AIとの対話を“ドキュメント”として固定化する仕組み

`deckrd` が解決しようとしている課題の 1つは、**AI との対話が「その場限りのログ」で終わってしまう**問題です。
このセクションでは、`deckrd` がどのようにして AI との対話を「後から使える設計資産」として固定化しているのかを説明します。

### 3.1 なぜ「ログ」では不十分なのか

チャット形式の AI との対話は、思考を進めるには非常に便利です。しかし、そのままでは次のような性質を持ちます。

- 時系列に並んだ発言の集合である
- 前提・結論・判断理由が混在する
- 後から必要な情報を取り出しにくい

対話ログをそのまま保存しても、以下のような問題が残ります。

- どこが Requirements なのか
- どこで仕様が確定したのか
- どの判断が最終決定なのか

このため、設計資料として再利用するのは困難です。

`deckrd` では、この状態を「対話が思考を前に進めるが、設計を残さない状態」と捉えています。

### 3.2 対話の結果を「構造化されたドキュメント」に落とす

`deckrd` では、AI との対話そのものを成果物としません。
対話によって得られた内容を、次のような形で**明確な役割を持つドキュメント**に落とし込みます。

- Requirements として整理する
- Specs として確定させる
- Implementations として判断をまとめる
- Tasks として実行単位に分解する

このプロセスによって、対話のなかで出てきたアイデアや判断は、
「どの段階の情報なのか」が明示された形で保存されます。

重要なのは、**対話は一時的でも、ドキュメントは永続的である**という前提です。

### 3.3 AI は「答えを出す存在」ではなく「思考を確認する存在」

`deckrd` における AI の役割は、最終的な答えを出すことではありません。
主な役割は次の通りです。

- 要求が不足していないかを確認する
- 仕様に矛盾や曖昧さがないかを指摘する
- 実装方針の選択肢を洗い出す
- タスクリストがテスト可能な粒度になっているかを確認する

AI は、人間の思考を外から確認し、抜けやズレを見つけるための装置として使われます。
その結果として確定した内容だけが、ドキュメントに反映されます。

### 3.4 フェーズごとに「確定させるもの」を意識する

`deckrd` では、フェーズが進むごとに「この段階で何を確定させるのか」を意識します。

- Requirements フェーズでは、要求を確定させる
- Specs フェーズでは、振る舞いと構造を確定させる
- Implementations フェーズでは、実装方針を確定させる
- Tasks フェーズでは、作業単位を確定させる

AI との対話は、この「確定」の判断を支援するために使われます。
確定した内容はドキュメントに反映され、次のフェーズの前提条件になります。

### 3.5 「対話を残す」のではなく「設計を残す」

`deckrd` が目指しているのは、AI との対話をすべて保存することではありません。
つぎのような「なぜ」を残しています。

- なぜその要求を採用したのか
- なぜその仕様にしたのか
- なぜその実装方針を選んだのか

すなわ、**設計の判断結果**です。

AI との対話は、その判断に至るための過程に過ぎません。
`deckrd` は、対話を「設計を生み出すための道具」として使い、
最終的に残すべきものをドキュメントとして固定化します。

次のセクションでは、この考え方を具体的な運用に落としたとき、
`deckrd` のワークフローがどのようになるのかを見ていきます。

## 4. `deckrd` のワークフロー概要

ここで、**`deckrd`の実際のワークフロー**をみていきます。このワークフローからは、どのように「Your Goals to Tasks」を実現しているかを見ることができます。

`deckrd` のワークフローのポイントは、**ドキュメントの作成順序と、それぞれのドキュメントの役割**にあります。

### 4.1 ワークフロー全体像

`deckrd` の基本的な流れは、次の通りです。

1. Goal を言語化する
2. Requirements を整理する
3. Specs を定義する
4. Implementations を検討する
5. Tasks に落とし込む

重要なのは、この流れが「一度きりで完結するもの」ではない点です。
各フェーズはドキュメントとして残り、後のフェーズでの変更に応じて前のフェーズへ戻ることができます。

### 4.2 Goal から Requirements へ

ワークフローは、まず Goal を言語化するところから始まります。

- 何を達成したいのか
- 何ができるようになれば成功なのか
- 今回は対象外とすることは何か

AI との対話を通じて Goal を掘り下げ、その結果を Requirements として整理します。この段階では、実装方法や技術選択は意識しません。
Requirements は、後続のすべての判断の基準になるため、**曖昧さを残さないこと**が重要です。

### 4.3 Requirements から Specs へ

次に、Requirements を具体的な仕様である Specs に落とし込みます。

- どのような振る舞いが必要か
- どのような制約があるか
- どの状態を満たせば Requirements を満たしたと言えるか

Specs は、実装に依存しない形で記述されます。
この段階で、AI は仕様の抜けや矛盾を見つけるためのレビュー役として機能します。

### 4.4 Specs から Implementations へ

Specs が固まったら、それをどのように実現するかを検討します。
ここが Implementations フェーズです。

- 採用する技術スタックの候補
- アーキテクチャの方向性
- 実現しない選択肢とその理由

Implementations は、Tasks を作るための前提条件をまとめたドキュメントです。
この段階での判断は、後から変更される可能性がありますが、その場合でも「なぜ変更したのか」を Decision Records として残せます。

### 4.5 Implementations から Tasks へ

最後に、Implementations を元に Tasks を作成します。

`deckrd` では、Tasks の粒度を **ユニットテストでの1つのテストケース**と定義しています。
このため、タスクリストのタスクは、次の意味を持ちます。

- コードを実装するときの明確な単位
- 明確な仕様

タスクリストは、`deckrd` の最終成果物であるだけでなく、実装の出発点でもあります。

### 4.6 ドキュメントがワークフローを支配する

`deckrd` のワークフローにおいて、中心にあるのは常にドキュメントです。

- AI との対話は思考を進めるための手段
- フェーズ間の移動はドキュメントの更新として表現される
- 判断の履歴は Decision Records として残る

この構造によって、ワークフロー全体が **後から追跡・修正・再利用可能**になります。

次のセクションでは、このワークフローを他の AI 支援開発手法、特に SDD と比較しながら、`deckrd` の立ち位置を整理します。

## 5. SDD の仕様書と `deckrd` が扱う要件の粒度の違い

`deckrd` と SDD の関係を理解するうえで重要なのは、
工程の前後ではなく、**扱う対象の粒度の違い**です。

`deckrd` は SDD の前段に位置するものではありません。
SDD で扱われる仕様書・要件定義書のなかの **「1つの要件」「1つの仕様」**を、独立した設計単位として扱うフレームワークです。

### 5.1 SDD の仕様書が扱うスコープ

SDD における仕様書や要件定義書は、次のような特徴を持ちます。

- プロダクトや機能群を俯瞰した仕様
- 複数の要件・仕様をまとめたドキュメント
- 実装を進めるための包括的な前提条件

この仕様書のなかには、**複数の設計単位**が含まれます。

- 機能 A の要件
- 機能 B の仕様
- 制約条件や非機能要件

といったものです。

### 5.2 deckrd が対象とするのは「仕様1つ」「要件1つ」

`deckrd` が扱うのは、SDD の仕様書全体ではありません。
そのなかに含まれる、設計対象:

- 要件定義書に書かれた「要件 1つ」
- 仕様書に書かれた「仕様 1つ」

です。
これらの設計単位を、`deckrd`は整理します。

- なぜこの要件が必要なのか
- どこまでを対象範囲とするのか
- どの仕様で満たすのか
- どう実装し、どう検証するのか

以上を、Requirements → Specs → Implementations → Tasks の流れで整理します。

### 5.3 粒度を小さくすることで得られるもの

対象を「仕様 1つ」「要件 1つ」に限定することで、次の効果が得られます。

- 思考の前提が明確になる
- 判断の理由をドキュメントとして残しやすい
- 影響範囲を限定した試行錯誤ができる
- 要件変更時の手戻りを局所化できる

これは、大きな仕様書全体を一度に扱う SDD では難しい部分です。

### 5.4 `SDD` と `deckrd` の関係性

この整理に基づくと、両者の関係は次のようになります。

- `SDD`:
  - 複数の要件・仕様を束ねた仕様書を扱う
  - 実装フェーズを高速に進める

- `deckrd`:
  - SDD の仕様書に含まれる「一要件・一仕様」を扱う
  - その要件の設計意図・判断・実装方針を明確にする

`deckrd` で整理された成果物は、
SDD の仕様書の一部として自然に組み込めます。

### 5.5 「前段」ではなく「設計単位としての補完」

この意味で、deckrd は SDD の前段ではありません。
**SDD の仕様書を構成する最小単位を担う補完的な存在**です。

- 大きな仕様書は SDD が扱う
- そのなかの一要件・一仕様は `deckrd` が深掘りする

これによって、次の効果が期待できます。

- 設計意図が失われにくい
- AI との対話による判断が再利用可能
- SDD の仕様書自体の品質の工場

次のセクションでは、この特性を踏まえて、
`deckrd` が特に効果を発揮するプロジェクトのタイプを整理します。

## 6. `IDD`（イシュードリブン開発）との組み合わせ

`IDD`（イシュードリブン開発）は、開発対象を `GitHub Issues` として明示し、進捗や責務を可視化する開発手法です。
`deckrd` は、この `IDD` と組み合わせることで、**Issue の背景にある設計意図をドキュメントとして固定化**できます。

### 6.1 Issue を「作業単位」ではなく「設計単位」として扱う

`IDD` では、Issue は主に次の役割を担います。

- 実装すべき作業の可視化
- 優先度や進捗の管理
- 議論や意思決定の集約点

一方で、Issue そのものは「なぜその Issue が必要なのか」「どの要求から生まれたのか」といった設計背景を十分に保持できません。
ここに `deckrd` を組み合わせることで、Issue を次のように拡張できます。

- 1 Issue = 1 要件 (または小さな設計単位)
- Issue の背後に Requirements / Specs / Implementations / Tasks を持たせる
- Issue を閉じた後も、設計判断をドキュメントとして再利用可能にする

### 6.2 `deckrd` を Issue の設計ドキュメントとして使う

実運用では、次のような流れが自然です。

1. `GitHub Issues` に「やりたいこと」を Issue として起票
2. Issue を対象に `deckrd` でドキュメントを作成
   - Requirements: Issue が満たすべき要求
   - Specs: 要求を満たすための仕様
   - Implementations: 実装方針と選択理由
   - Tasks: テスト可能な実装タスク
3. Tasks をもとに実装を進める
4. Issue をクローズしても、設計ドキュメントは残る

この構成では、Issue は単なるタスク管理ではなく、**設計のインデックス**として機能します。

### 6.3 Issue を複数の `deckrd` に分割するケース

Issue の粒度が大きい場合、1つの Issue を複数の設計単位に分けたほうがよい場合もあります。

- 1つの Issue に複数の要件が含まれている
- 機能的に独立した仕様が混在している
- 実装順や検証方法が異なる

この場合でも、Issue を起点に複数の `deckrd` ドキュメントを作成すれば問題ありません。
重要なのは、**設計単位を小さく保ち、判断の理由を追跡可能にすること**です。

### 6.4 IDD × deckrd で得られる効果

`IDD` と `deckrd` を組み合わせることで、次の効果が期待できます。

- Issue の背景となる設計意図が失われにくい
- AI との対話による判断を再利用できる
- Issue ベースの開発でも、設計の一貫性を保てる
- 後から仕様変更があっても、見直す起点が明確になる

この構成により、`deckrd` は **Issue 駆動の開発を、設計駆動へと引き上げる補助線**として機能します。

## 7. どんなプロジェクトで deckrd は有効か

`deckrd` は、大規模プロジェクト向けの重厚な設計フレームワークとして設計されたものではありません。
もともとは、**個人プロジェクトにおけるマイクロ SDD (仕様書駆動開発) フレームワーク**として生まれています。

そのため、基本思想は一貫して **軽量・高速・アジャイル** です。
このセクションでは、その前提を踏まえて `deckrd` が特に有効なプロジェクトの特徴を整理します。

### 7.1 個人開発・少人数開発におけるアジャイルなプロジェクト

`deckrd` が最も自然にフィットするのは、次のような開発スタイルです。

- 個人開発、または少人数チーム
- 要件定義と実装を並行して進める
- 作りながら考え、途中で方向修正する

`deckrd` は、1つの巨大な仕様書を作ることを目的としません。
**1つの Goal、1つの要件、1つの仕様**を最小単位として扱うため、
アジャイル開発のテンポを落とさずに設計を残せます。

### 7.2 「設計を最初に固めない」前提のプロジェクト

個人プロジェクトやアジャイル開発では、次のような状況が前提になります。

- 最初から正解の設計はわからない
- 作ってみて初めて要件のズレに気づく
- 技術選定や仕様は途中で変わる

`deckrd` は、Requirements / Specifications/ Implementations を分離しています。

- どの判断を変えたのか
- どこから作り直すのか

を明確にしたまま、**素早く作り直す**ことができます。

### 7.3 AI を相棒にした高速な試行錯誤

`deckrd` は、AI と一緒に考えながら作ることを前提としています。

- Goal を言語化する
- 要件や仕様を AI にレビューさせる
- 実装方針の選択肢を洗い出す

ただし、AI との対話そのものを残すことは目的ではありません。
**最終的に確定した判断だけをドキュメントとして残す**ため、
スピード感を維持したまま設計の再利用性を確保できます。

これは、短いサイクルで仮説検証を回すアジャイルな個人開発と相性のよい特徴です。

### 7.4 SDD を「重く感じていた」プロジェクト

SDD を試してみたものの、次のように感じたケースにも `deckrd` は向いています。

- 仕様書を書くコストが高い
- 変更のたびにドキュメントが追いつかない
- 個人開発にはオーバースペックに感じる

`deckrd` は、SDD の考え方を **最小単位まで分解**したフレームワークです。
必要な部分だけを取り出して使えるため、
**マイクロ SDD**として、無理なく設計を取り込めます。

### 7.5 deckrd は「速く作るための設計フレームワーク」

`deckrd` の目的は、設計を厳密に管理することではありません。

- 迷いを減らす
- 判断の理由を忘れない
- 作り直しを速くする

そのための、**軽量な設計フレームワーク**です。

個人プロジェクトやアジャイル開発において、
「考えたことを最小限のコストで残したい」
そう感じる場面で、`deckrd` は最も力を発揮します。

次のセクションでは、これらのドキュメントを入力として、
実装を自動化する `deckrd-coder` について紹介します。

## 8. `deckrd-coder` と Tasks が実現する「実行できる仕様書」

`deckrd-coder` が扱う `tasks.md` は、一般的なタスクリストや TODO とは性質が異なります。
それは **実装可能であり、かつ実行可能な仕様書** です。

この章では、実際の `tasks.md` の構造を踏まえながら、
なぜ `deckrd` の Tasks がそのまま実装に耐えるのかを整理します。

### 8.1 Tasks は「作業指示」ではなく「仕様の最小単位」

`tasks.md` に記載されている各 Task は、次の形式で統一されています。

- Task ID による一意な識別
- Given / When / Then による振る舞いの定義
- 正常系 / 異常系 / エッジケースの明示
- 型・export・構造まで含めた検証条件

これは、単なる「やることリスト」ではありません。
**1 Task = 1 テスト可能な仕様** という位置づけです。

そのため Tasks をすべて満たす実装は、そのまま仕様を満たした実装になります。

### 8.2 Tasks がそのまま BDD になる理由

`tasks.md` の各項目は、明確に BDD (`Behavior Driven Development`) を意識した構造を持っています。

```bash
Given: 前提条件
When: 実行される操作
Then: 期待される結果
```

この形式により、以下の特性が生まれます。

- 実装者の解釈が、ほぼ入り込まない
- テストコードへ機械的に変換できる
- AI が「何を満たせばよいか」を誤解しにくい

`deckrd-coder` は、この Tasks を **仕様として忠実に実装する実行エンジン**として機能します。

### 8.3 実装可能性を保証する Tasks の粒度

掲載されている `tasks.md` では、Tasks の粒度が厳密に制御されています。

- 型定義・enum・const などの構造要素
- 正常系・異常系・エッジケースの網羅
- 戻り値の型・export 可否・可視性
- 実行環境（Node / Deno / Bun）ごとの挙動

これにより、実装時には以下の状態になります。

- 曖昧な「あとで考える」ポイントが残らない
- 実装途中で仕様を補完する必要がない
- 実装完了の定義が明確になる

Tasks は、**「ここまで作れば完成」という完成条件そのもの**です。

### 8.4 Tasks を満たす = ドキュメントを満たす

重要なのは、`tasks.md` が単独で存在しているわけではない点です。

- Requirements
- Specifications
- Implementations
- Decision Records

これらのドキュメントを前提にして Tasks が導出されています。

- Tasks を満たす実装は Requirements を満たす
- Tasks を満たす実装は Specs を満たす
- Tasks を満たす実装は Implementation の判断に従っている

という関係が成立します。

Tasks は最終成果物でありながら、
**上流の設計ドキュメントすべてとトレーサブルに結びついた仕様書**でもあります。

### 8.5 `deckrd-coder` は「仕様を実行する」存在

`deckrd-coder` の役割は、仕様を解釈して設計を考えることではありません。

- 仕様は `deckrd` で確定済み
- Tasks は実装可能な形に落ちている
- 実装時に判断を持ち込まない

この前提のもとで、`deckrd-coder` は Tasks を順に実装します。

これは、
**「仕様を読む」のではなく「仕様を実行する」**
という感覚に近いアプローチです。

### 8.6 実行できる仕様書がもたらす開発体験

この構造によって、次のような開発体験が得られます。

- Tasks がそのまま実装計画になる
- 実装が進むごとに仕様の達成度が可視化される
- 仕様変更時は Tasks を変更すればよい
- AI 実装の結果が安定する

`deckrd` と `deckrd-coder` の組み合わせは、
**「考える」と「作る」を分離したまま、高速に往復できる開発**を可能にします。

`tasks.md` は、その中核となる
**実行可能な仕様書**です。

## おわりに

`deckrd`は、そもそも Agent Skills が`codex`や`copilot`でも使えるようになったという話から作成したものです。
はじめは、Agent Skills の記事は見かけるけど実際に作ってみたサンプルは見ないな。じゃぁ、自分がやってみるかという軽い気持ちでした。
しかし、予想以上に使い勝手がよく、自分が欲しいものは自分が一番よく知っているを実感しているところです。

とくに、タスクリストまで作成すれば、あとは AI 任せにできるというのはすごいメリットでした。
`deckrd`を使って、いろいろな OSS を開発したい。ただし、AI の 5時間リミットがきつい。

それでは、Happy Hacking!

## 参考資料

### Webサイト

- deckrd github: <https://github.com/aglabo/deckrd>
  deckrd の GitHub リポジトリ

- README: <https://github.com/aglabo/deckrd/blob/main/plugins/deckrd/README.md>
  deckrd GitHub リポジトリの README

- deckrd coder README: <https://github.com/aglabo/deckrd/tree/main/plugins/deckrd-coder/README.md>
  `deckrd coder` GitHub リポジトリの README
