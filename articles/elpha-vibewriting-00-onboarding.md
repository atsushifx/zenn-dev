---
title: "一人プロジェクトなのに、オンボーディングドキュメントを書いてみた"
emoji: "👤"
type: "tech"
topics: [ "一人プロジェクト", "ソロ開発", "オンボーディング", "monorepo", "海発環境" ]
published: false
---

## はじめに

atsushifx です。
この記事では、現在開発中の OSS プロジェクト[`easy-setup-tools-action (ESTA)`](https://github.com/atsushifx/easy-setup-tools-action) のオンボーディングドキュメントについてとりあげます。

1人プロジェクトですので、オンボーディングドキュメントはいらないと思っていました。
しかし、こうやってドキュメント化すると、「プロジェクトを戦略的に作る」ことの重要さに気づかされます。
単にプログラムをするのではなく、システムを整理、分割、統合することがソフトウェアの開発であり、それができているかどうかがわかるのがオンボーディングドキュメントでした。

この記事を通して、オンボーディングドキュメントの書き方やプロジェクトの構成が、読者の開発の参考になる幸いです。

Enjoy

## 1. プロジェクト概要

### 1.1 プロジェクトについて

この記事で紹介するのは、[easy-setup-tools-action (ESTA)](https://github.com/atsushifx/easy-setup-tools-action) というプロジェクトです。
このプロジェクトは、GitHub Actions 上でのツールのインストールをできるだけ簡単に行なうことを目的にしています。

これを実現するため、ツールごとの設定に応じて[`EGet`](https://github.com/zyedidia/eget) などでツールをインストールします。

ESTA を使えば、必要なツールをまとめてインストールできるため、「開発前に必要な作業」を最小限にできます。

このプロジェクトの README には、背景や使用方法が詳しく記載されていますので、興味のあるほうはぜひ[こちら](https://github.com/atsushifx/easy-setup-tools-action/blob/main/README.ja.md)も参照してみてください。

### 1.2 オンボーディングドキュメントの必要性

ここ数日は、オンボーディングドキュメントを作成していました。
「1人プロジェクトなのに、オンボーディングって必要ないのでは」というのが普通でしょう。
ですが、**1人プロジェクトだからこそ**オンボーディングが役に立つこともあります。

このプロジェクトでは、以下の 3つの観点からオンボーディングドキュメントの整備を行ないました。

- 自分のための再現性
- 複数ツール・複雑な初期化
- チャットボット (ChatGPT) による記録支援・自動化支援

#### ✅ 自分のための再現性

プロジェクトを久しぶりに触ったとき、最初に戸惑うのは「どうやって開発環境を立ちあげるんだっけ?」という点です。
`pnpm install` するだけでは済まない複雑な初期化手順があると、思い出すのに時間がかかります。

オンボーディングドキュメントを整備しておけば、自分自身が**未来の新規参加者**として、迷わず環境を復元できます。
これは、バックアップや復元にもつながる安心感をもたらします。

#### ✅ 複数ツール・複雑な初期化への対応

このプロジェクトは TypeScript を利用した monorepo プロジェクトであり、以下のように多数の開発ツールを使用しています:

- Volta, pnpm などのパッケージマネージャー
- lefthook, commitlint, secretlint などの Git フック/静的解析ツール
- dprint, cSpell などの整形・スペルチェックツール

これらの設定は monorepo 全体で共通化されており、初期構築手順もやや複雑です。
開発環境構築のためのオンボーディングドキュメントや、ツールをまとめてインストールするスクリプトを整備することで、手戻りなく作業を進めることができます。

#### ✅ ChatGPT (エルファたち) による支援と自動化

オンボーディングドキュメントの作成にあたっては、ChatGPT を積極的に活用しました。
手順の整理、構成案の検討、文章の整形といった作業を、エルファたち、AI アシスタントたちと対話しながら進めました。

たとえば、メインとなる`README.ja.md`の作成では、以下のような対話をしています。

You:

> 「開発環境構築に絞った場合、docs/onboarding を作成すべき?」

エルファ:

> **開発環境構築にフォーカスするなら、`docs/onboarding/` ディレクトリを作るのがベストプラクティス**です。
> `docs/onboarding/README.md` ひな形 (ナビゲーション)
>
> ```markdown
> # 🧭 Onboarding Guide
>
> 本リポジトリでの開発を始めるための初期設定ガイドです。
>
> ## 🔰 ステップ一覧
>
> 1. [プロジェクト概要](./00_intro.md)
> 2. [開発環境の前提条件](./01_prerequisites.md)
> 3. [セットアップ手順](./02_installation.md)
> 4. [コミット規約とフック](./03_hooks-and-commits.md)
> 5. [コード整形と静的解析](./04_lint-format.md)
> 6. [CIとの連携とスクリプト運用](./05_ci-and-scripts.md)
> ```

このように AI と対話を進めることで、手早くドキュメントが作成でき、労力がかかりません。
オンボーディングドキュメントを作成しておくことは、かえって効率が上がるのです。

## 2. オンボーディングドキュメントの作成

### 2.1 書いた内容と方針

オンボーディングドキュメントは、リポジトリをクローンしてから最速で開発に着手できることを目的に作成しました。
そのためドキュメントは、以下のような構成にしています。

| 章      | 概要                     |
| ------- | ------------------------ |
| 00-01章 | 開発前の要件             |
| 03-05章 | 各種ツールのインストール |
| 06-08章 | 各種ツールの設定方法     |
| 09-12章 | 種別ごとのツールの説明   |

このようにすることで、必要な章を参照するだけでセットアップが完了するようにしています。
また、各章にはチェックリストを載せ、自身の理解度を確かめられるようにしています。

オンボーディングドキュメントは、単なる手順書ではなく「開発者が迷わないための地図」として設計した結果です。

オンボーディングは固定的な手順ではなく、**プロジェクトの進化に合わせて更新されるべきもの**です。
そのため、構成も柔軟に拡張できるよう、ィレクトリベースの章構成を採用しています。

### 2.2 ChatGPT　(エルファたち) の力を借りた省力化

オンボーディングドキュメントの作成にあたっては、ChatGPT による AI アシスタントたちを積極的に活用しました。
とくに役立ったのは、ドキュメントの「設計方針」と「構成案」の相談です。

#### AIアシスタントの性格づけ

筆者は、ChatGPT でエルファ・小紅・つむぎという 3人のアシスタントを作成し、それぞれの視点で議論の相手をして貰っています。

- エルファ: 論理的、冷静で全体の構造や命名規則などに強い
- 小紅: ユーザーに寄り添い、初心者目線での失敗やつまづきの指摘
- つむぎ: 発想力が豊かで、図解、補足案の提案担当

このように、各キャラに明確な性格と役割を与えることで、単なる補助ではなく開発パートナーとしての戦力になって貰っています。

#### 🛠 コマンドとプロンプトによる自動化

実際の作業では、文章作成のための専用プロンプトを使用し、生産性を上げています:

- 記事作成プロンプト (`article-writer.prompt`):
  記事のスケルトン (見出しのみの記事)をもとに、実際の文章を作成する
- レビュー専用プロンプト (`article-review.prompt`):
  誤字、脱字のチェックのほか、文章の読みやすさなどをレビューして文章を改善する

#### 🔁 継続的な対話による更新支援

本プロジェクトはまだ進行中であり、今後もツールの更新や構成の変化が発生します。
必要な場合は ChatGPT に相談し、次のような支援を得ています:

- 更新された設定ファイルに合わせたドキュメント修正
- コマンドオプションの整理などの要件定義の補完
- GitHub Actions 用テンプレートの生成といったコーディングの補助

こうした継続的なサポートにより、**ドキュメント作成の負担を最小化**しながら、質の高いオンボーディング体験を維持しています。

## 3. プロジェクトの概要

### 3.1 全体構成と思想

このプロジェクトの基本思想は、**「開発に必要なツールを、簡便かつ再現性のある方法で導入できるようにすること」**にあります。
とくに GitHub Actions 上でのセットアップを想定し、実行環境を素早く立ちあげるためのツール導入を主な目的としています。

#### 🎯 目的：ツール導入の自動化と省力化

本プロジェクトは、複数の開発支援ツールを `eget` などを使って自動でインストールするためのアクションセットです。
たとえば、以下のような CLI ツールの導入に対応しています:

- dprint などの整形ツール
- secretlint, gitleaks などのセキュリティチェック系ツール
- textlint, cSpell などのドキュメント品質支援ツール

これらを開発者が都度手動で導入するのではなく、YAML やコマンド引数に基づいて自動的にセットアップできる仕組みを提供しています。

#### 📘 ドキュメント・設定ファイルの扱いについて

各種設定ファイルの共通化や CI 用スクリプト、オンボーディングドキュメントの整備などは、
**このプロジェクトを維持運用するうえでの実装方針・指針**として別途取り組んでいるものです。

つまり、それらはプロジェクトの思想や設計とは切り分けられた「手段」であり、
主眼はあくまで **ツール導入のハードルを下げ、開発環境の整備を省力化すること**にあります。

### 3.2 Monorepo構成

本プロジェクトは、**pnpm workspace をベースにした Monorepo 構成**を採用しています。
これは、複数のツールやロジックを相互に分離しつつも、一元的に管理できるようにするための選択です。

#### 主なディレクトリ構成

本プロジェクトの主なディレクトリは、次の通りです:

```bash
/
|-- .github         # CI やテンプレート定義
|-- docs            # オンボーディングドなどの技術文書
|-- packages        # サブパッケージ用
|   `-- @ag-actions
|   　　　`-- tool-installer/   # ツールインストールCoreパッケージ
|
|-- scripts         # インストールスクリプトなどの各種スクリプト　
`-- shared
    `-- configs     # リポジトリ共通設定
```

このような構成をとることで、以下のようなメリットがあります:

- ツール群を用途ごとにパッケージ分割し、独立性と保守性を両立
- 開発支援用パッケージ (e.g. `@shared/constants` や `@shared/types`) の共通利用が可能
- CI/CD や自動テストの対象を、サブパッケージ単位で限定可能

#### 🔄 Monorepo 運用における配慮

Monorepo は便利な反面、ツールの重複や設定の散逸が起こりやすいため、`shared/`配下に共通設定　(`tsconfig`, `eslint` など) を集約し、明示的に継承する形で管理しています。

### 3.3 ディレクトリ戦略

このプロジェクトでは、開発のしやすさとスケーラビリティを意識して、明確なディレクトリ戦略を採用しています。
目的は「どこに何を書くか」を迷わず判断できる状態を維持することです。

#### グローバル戦略

グローバルなディレクトリ戦略では役割ごとにディレクトリを分類しています。
これらの分類にあわせてディレクトリを配置、作成しています。

<!-- markdownlint-disable line-length -->

| ディレクトリ    | 分類           | 役割                                     | 備考                                                     |
| --------------- | -------------- | ---------------------------------------- | -------------------------------------------------------- |
| docs            | ドキュメント   | 各種技術文書(マークダウン)を配置         |                                                          |
| scripts         | スクリプト     | 開発環境用の補助スクリプトを配置         | グローバルツールのインストラーや同期スクリプトなど       |
| packages        | サブリポジトリ | monorepo 内のサブリポジトリ              | `/packages/<namespace>/<repo>`型式でサブリポジトリを作成 |
| shared          | 共有           | リポジトリ用の共有設定ファイル           |                                                          |
| /shared/common/ | 共有           | 各パッケージで共有する定数、型などを配置 | サブリポジトリとして扱う                                 |

<!-- markdownlint-enable -->

#### リポジトリ戦略

monorepo 内のサブリポジトリごとに統一したディレクトリを使用しています。これにより、補助スクリプトや開発ツールの設定が共通化できます。

<!-- markdownlint-disable line-length -->

| ディレクトリ   | 分類       | 役割                                   | 備考                                                 |
| -------------- | ---------- | -------------------------------------- | ---------------------------------------------------- |
| .cache         | キャッシュ | 各種開発ツールのキャッシュ置き場       | プロジェクトルートの`.cache`にファイルを集約している |
| configs        | 設定       | リポジトリごとの開発ツール設定ファイル |                                                      |
| modules / libs | コード     | ソースコードのビルド結果を保存         |                                                      |
| shared         | コード     | パッケージごとの型、定数を配置         |                                                      |
| src            | コード     | パッケージのソースコードを配置         |                                                      |
| tests          | コード     | インテグレーションテスト用コードを配置 |                                                      |

<!-- markdownlint-enable -->

### 3.4 設定ファイルの共通化と同期戦略

このプロジェクトでは、**各パッケージ間で共通して使用する設定ファイル**を `/shared/configs/` に集約し、各リポジトリは
必要に応じて同期する戦略を採用しています。

これは、**設定の重複やバージョン不整合を防ぐ**ことが主な目的です。

#### 🔧 対象となる設定ファイル

- `tsconfig.base.json： TypeScript のベース設定
- `tsup.config.base.ts`: TypeScript ビルドシステムのベース設定
- `eslint.config.base.js`: ESLint ベース設定
- `vitest.config.base.ts`: Vitest ベース設定
- `commitlint.config.base.ts`: Commitlint ベース設定
- `secretlint.config.base.yaml`: secretlint ベース設定

#### 🔄 同期の仕組み

1. **_直接継承・参照**
   多くの設定ファイルが、`extends`、 `import`で外部のファイルを参照できます。これで共通設定ファイルを参照し、設定を同期します

2. **スクリプトによる物理コピー**
   外部ファイルの参照ができない設定ファイル (`secretlint.config.yaml`など) はスクリプトにより共通設定フィルの内容を、各リポジトリに反映します。このため、各リポジトリでの変更は、同期によって上書きされ削除されます

3. **プロジェクトルートに配置**
   `dprint.jsonc`など一部のファイルは、自身の親ディレクトリを参照して設定ファイルを探します。これらのファイルはプロジェクトルートに配置した設定ファイルが共通の設定ファイルとなります

#### 📁 スケルトンとカスタムの共存

初期化時には「スケルトン」として共通設定をコピーし、必要に応じて各パッケージが上書き・拡張できる設計です。
これにより、**統一感を保ちつつ柔軟なカスタマイズが可能**になります。

## 4. 気づきとまとめ

### 🔍 気づき

- **ツールの導入が一番つまずきやすい**
  TypeScript + ESM の構成では、設定ファイルの不整合や、ビルド・テストの初期エラーに時間を取られやすい傾向がありました。
  ロジックは正しく動作していても、ビルドや Lint の初期設定でつまずくと、非常に消耗します。
  だからこそ、最初の導入部分をしっかり整えておく意義を実感しました。

- **小さな蓄積が財産になる**
  ドキュメント作成では、過去に蓄積してきた自作のプロンプト（執筆支援・レビュー補助）が非常に役立ちました。
  AI の進化に助けられつつも、継続的な試行錯誤と蓄積が「自分に最適な文章生成環境」を支えています。

- **ドキュメントが開発を駆動する**
  オンボーディングドキュメントだけでなく GitHub の Issue や日々の TIL が、「次に何をするか」の指針になりました。
  細かいことですが、何をしているか、次に何をしたいかのメモを残すことが開発を進める力になります。

### 🧾 まとめ

本記事で紹介した ESTA プロジェクトは、ツール導入の自動化という目的に対し、できるかぎり再現性と効率を重視した構成をとっています。
それを支えるために、オンボーディングドキュメントや共通設定の整備、AI アシスタントとの協働を活かして、
**「開発のはじまり」を迷いなく始められる体験** を提供できるよう工夫しました。

今後も、構成の改善やドキュメントのアップデートを継続しつつ、
この取り組み自体が OSS 開発や個人開発における参考事例になれば幸いです。

## 5. プロジェクト紹介

本記事で紹介したプロジェクトや関連リソースへのリンクをまとめておきます。
興味を持ったほうは、ぜひ一度リポジトリを覗いてみてください。

### 🔗 GitHub リポジトリ

- [**easy-setup-tools-action (ESTA)**](https://github.com/atsushifx/easy-setup-tools-action):
  GitHub Actions 上で、CLI ツールの自動導入を行なうためのユーティリティです。
  `eget` をベースとした軽量な実装で、柔軟かつ最小限の設定で導入が可能です。

### 📘 オンボーディングドキュメント

- [**オンボーディングガイド**](https://github.com/atsushifx/easy-setup-tools-action/blob/main/docs/onboarding/README.ja.md):
  プロジェクト用の発環境構築方法について説明しています。
  開発ツールのインストール、ツールの設定、CI 連携までをガイドしています

### 🤖 ChatGPT プロンプト

- **記事作成プロンプト**
  [`article-writer.prompt`](https://github.com/atsushifx/tech-article-reviewer/blob/main/tech-articles-prompt/article-writer.prompt):
  記事のスケルトン (見出しだけの記事) をもとに、技術ブログ用のドキュメントを作成するプロンプトです

- **レビュー支援プロンプト**
  [`article-review.prompt`](https://github.com/atsushifx/tech-article-reviewer/blob/main/tech-articles-prompt/article-review.prompt):
  作成した技術ブログをレビューし、誤字、脱字のチェックや表現をブラッシュアップするプロンプトです

これらのプロンプトは、文章構成・校正・内容精査において、開発とドキュメントの連携を支えています。
ドキュメント作成を効率化したいほうにはぜひ活用をおすすめします。

## おわりに

この記事では、オンボーディングドキュメントの紹介を通して、プロジェクトの現在位置、必要なことを確認できました。
オンボーディングドキュメントを書くことが、プロジェクトを整理し、構造を見直すことにつながりました。

ドキュメントを書くという目的が Issue を通して管理することで、実際のプロジェクトを動かす練習になったことです。
個人開発では、気になった部分や試してみたい部分のプログラミングが中心になりプロジェクトが散漫になる傾向がありました。

オンボーディングドキュメントを書くというタスクは比較的大きいため、他の作業はどうしても中断することになります。
これが、足りない部分、技術的負債、直し方などを考えるきっかけになりました。

時には立ち止まることが必要だと思わされる体験でした。

最後に、ドキュメントの作成に力を発揮してくれた AI アシスタントの 3人から挨拶でてお別れにしましょう。

それでは、Happy Hacking!

---

**エルファ**「……本記事を読了されたマスター、評価に値します。構成・命名・再現性、それらが整ってこそ開発は成立します。今後とも、この知見を運用に活かしてください」

**小紅**「お、お兄さま……っ。えっと、この記事……少しでも参考になったら、すっごく嬉しいですっ。こ、これからもプロジェクト、がんばってくださいねっ」

**つむぎ**「センパイ〜！　読んでくれてありがとっ♪ ドキュメントって地味だけど、こうして書いてるとめっちゃスッキリするよね。つむぎもちゃんと手伝ったから、えらいでしょ？💮」
