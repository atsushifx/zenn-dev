---
title: "deckrd: 「やりたい」を実装可能なタスクに変えるドキュメントフレームワーク"
emoji: "🧭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["deckrd", "SDD", "仕様書駆動開発"]
published: false
---

<!-- textlint-disable ja-technical-writing/sentence-length -->
<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->
<!-- textlint-disable ja-technical-writing/max-ten -->
<!-- markdownlint-disable no-emphasis-as-heading -->

## はじめに

atsushifx です。
この記事では、ドキュメント指向の思考補助フレームワーク `deckrd` を紹介します。

`deckrd` は、AI との対話を通じて行われた設計上の判断や前提を、
結果だけでなく文脈として整理・記録することを目的としたフレームワークです。
コーディングエージェント AI が備える Agent Skills を利用し、
Goal から Tasks までの判断を段階的にドキュメントへ落とし込んでいきます。

特徴は、重厚な仕様書を前提とせず、
試行錯誤しながら設計を更新していく開発スタイルに合わせて使える点にあります。
個人開発や OSS 開発、AI と併用した設計において、
「考えた過程」を無理なく残したい場面を想定しています。

この記事では、`deckrd` がどのような考え方で設計を整理し、
判断をドキュメントとして扱うのかを紹介します。

Enjoy!

## 用語集

- `deckrd`
  AI との対話を通じて得られた判断や前提を、設計の文脈として整理・記録するためのドキュメント指向フレームワーク。

- `Agent Skills`
  生成 AI に特定の役割・制約・入出力ルールを与え、状況に応じて呼び出される再利用可能な振る舞いの単位。

- **Your Goals to Tasks**
  Goal を起点に、設計判断を段階的に積み重ね、最終的に Tasks まで一貫した文脈として導く考え方。

- Goal
  設計の出発点となる、達成したい状態や目的の定義。

- Requirements
  Goal を満たすために必要な条件や要件の整理。

- Specifications
  Requirements を満たすための振る舞いや構造を、実装から切り離して定義した仕様。

- Implementations
  仕様をどのような方針で実現するかという、実装上の判断や設計方針の整理。

- Tasks
  実装と検証に着手できる、検証可能な作業単位。

- Decision Records (DR)
  設計の過程で行われた判断や前提、その変更理由を記録するための判断単位。

- `SDD` (`仕様書駆動開発`)
  仕様書を中心に設計と実装を進める開発手法。複数の要件や仕様を束ねた文書を設計単位として扱う。

- AI 支援開発
  生成 AI を用いて、要件整理、仕様検討、設計レビューなどを補助しながら進める開発スタイル。

- 設計単位
  設計上の判断や検討を整理・記録するための最小の対象単位。

- ドキュメント指向
  設計の進行や判断の履歴を、対話や操作ではなくドキュメントの更新として表現する考え方。

## 1. なぜ「AIに設計を任せる」と破綻しやすいのか

AI を使えば、仕様案やタスクを短時間で得られます。
しかし、その設計があとから再利用できないと感じたことはないでしょうか。

この章では、AI に設計を任せたときに起きやすい問題を整理し、
なぜ「結果だけが残り、判断が残らない設計」になりやすいのかを明らかにします。

### 1.1 AI に設計を任せると、何が失われるのか

AI との対話を通じて設計を進めると、次のような流れになりがちです。

![AI設計が断片化する構造](/images/articles/oss-deckrd/deckrd-01-fragmentation-s.png)

*図1-1: AI設計が断片化する構造*

この流れでは、成果物は得られても、次のような設計の文脈が残りません。

- 判断に用いた前提条件
- 結論に至った理由
- 設計として確定した範囲

また、AI に設計を任せると、以下のような問題が起きやすくなります。

| 問題         | 何が起きるか       | なぜ再利用できないか |
| ------------ | ------------------ | -------------------- |
| 記録されない | 判断理由が残らない | 前提が説明できない   |
| 再現できない | 判断経路が辿れない | 同じ設計に戻れない   |
| 結果偏重     | 結論だけが残る     | 設計意図が消える     |

*表1-1: AI設計が断片化する理由の整理*

### 1.2 AIとの対話では、設計が結果だけに収束する

AI を用いた設計は、多くの場合チャット形式の対話によって進められます。この形式では、やり取りそのものはログとして残りますが、どの判断を、どの前提にもとづいて確定したのかが、設計として整理されないまま進むことが多くなります。

対話のなかでは、前提条件の確認や判断理由の言語化、別案の検討といった思考が自然に行われます。しかし、それらは発言の流れのなかで消費され、設計として確定した判断と、検討途中の思考とが区別されないまま進行していきます。

その結果、後から参照できる形で残るのは、最終的な結論や生成結果だけになります。なぜその結論に至ったのか、どの前提が有効だったのかといった判断の経緯は、設計の記録として切り出されません。

判断の経路が残らないため、設計の文脈を再現することも難しくなります。同じ目的や要求を与えても、以前と同じ設計にたどり着けなくなり、設計を説明したり、別の状況で再利用したりができなくなります。

この状態では、設計が成立しているように見えても、それは一時的に整合しているだけです。結果は残っていても、判断の前提や理由が失われているため、設計としては使えないものになります。

### 1.3 問題は「AI」ではなく「設計の扱い方」にある

ここまで見てきた問題は、AI の性能や精度によって生じているものではありません。
AI による出力が不十分なのではなく、その出力や対話の過程を、設計としてどのように扱っているかに原因があります。

AI との対話のなかでは、前提条件の確認や判断理由の言語化、検討の経緯といった設計に必要な情報が自然に現れます。
しかし、それらが設計の記録として整理されないまま流れていくと、設計は結果だけが残る形になります。

判断の前提や経緯が固定されない状態で対話を重ねると、設計の文脈は揺れ、結論はその場ごとに変わっていきます。
仕様やタスクが残っていたとしても、それを支える判断や意図を説明できなくなります。

要求、前提、判断、結論が切り離されたまま使われる限り、AI を用いた設計は何度でも断片化します。
問題は AI に設計を任せたことではなく、設計を記録として扱わなかったことにあります。

## 2. `deckrd` が目指す「Your Goals to Tasks」という考え方

`deckrd` は、AI との対話を「結果」ではなく設計の文脈として残すことを目的としたフレームワークです。
その中核となるのが、「Your Goals to Tasks」という考え方です。

### 2.1 なぜ「Your Goals to Tasks」が必要なのか

第1章で見てきたように、AI を使った設計が断片化しやすい背景には、
対話の結果は残っても、判断に至る文脈が設計として残らないという問題があります。

AI との対話によって仕様やタスクは生成されますが、その判断がどの前提や意図に基づいていたのかは、後から追跡しにくいままです。

「Your Goals to Tasks」という考え方は、設計判断の積み重なりを、Goal から Task まで一貫した文脈として記録するための枠組みです。

`deckrd` が重視しているのは、仕様やタスクそのものではなく、それらに至るまでの判断が、どの Goal を前提に積み重ねられてきたかという点です。

この判断の流れを、Goal から Tasks まで一貫した文脈として扱えるかどうかが、設計を再利用可能な資産にできるかを分けます。

### 2.2 設計の文脈が固定されない理由

AI 支援開発を含め、多くの開発では、設計の前提となる Goal が明示されないまま作業が始まります。
Issue の作成や仕様の一部記述、実装方法の検討といった作業は、それぞれ妥当であっても、どの Goal を前提としているのかが共有されないまま進行しがちです。

この状態では、途中で前提や方向性を見直す必要が生じた際に、どの判断が有効で、どこから設計を組み直すべきかを判断する手がかりが残りません。
その結果、設計は更新されているように見えても、判断の積み重なりとしては追跡しづらくなります。

### 2.3 Goal を起点に設計するという発想

`deckrd` では、設計の文脈を固定するために、作業の出発点として Goal を具体化し、共有するという考え方を採用します。
Goal を先に言語化することで、後続の判断がどの方向に向かっているのかを確認しやすくなります。

Goal を起点に据えることで、設計の過程では次の点が整理されます。

- 成功とみなす条件
- 対象外とする範囲
- 判断時の基準

このような前提を共有したうえで AI と対話すると、
生成される仕様やタスクは Goal との対応関係を保ちやすくなります。

このとき AI は、答えを提示する存在ではなく、
Goal を前提に思考を整理し、後続の判断を支えるための補助役として機能します。

### 2.4 Goal から Tasks までを一貫して導く構造

Goal を起点とした設計は、単に上流から下流へ作業を流すことではありません。
図 2-1 が示しているのは、工程の順序ではなく、各段階で「何を判断しているのか」という役割の違いです。

`deckrd` では、Goal を起点として、次の段階を順に経ながら Tasks へと導きます。

- `Requirements`: Goal を満たすための条件整理
- `Specifications`: 条件を満たす振る舞いと構造の定義
- `Implementations`: 実現方法の検討と選択理由
- `Tasks`: 検証可能な作業単位への分解

| フェーズ        | 役割         | ここで決めること       |
| --------------- | ------------ | ---------------------- |
| Goal            | 目的の定義   | 何を達成したいか       |
| Requirements    | 条件整理     | 何を満たす必要があるか |
| Specifications  | 振る舞い定義 | どうあるべきか         |
| Implementations | 方針判断     | どう実現するか         |
| Tasks           | 作業分解     | 何を実行・検証するか   |

*表 2-1: Your Goals to Tasks の構成要素対応*

![Your Goals to Tasks の基本フロー](/images/articles/oss-deckrd/deckrd-02-basicflow.png)

*図 2-1: Your Goals to Tasks の基本フロー*

この流れは、作業工程ではなく、判断の役割を整理するための枠組みです。

Goal から Tasks に至るまでの判断をこの形で整理し、記録していくことで、
`deckrd` は設計の結果だけでなく、思考の過程も含めて残すドキュメント構成を取ります。

### 2.5 `Implementation` は「実装」ではない

`deckrd` における Implementation は、コードを書く工程そのものではなく、後続の Tasks を導くための判断を整理する段階です。
仕様をどのような方針で実現するかを定める、実装上の判断や設計方針を整理する段階です。

この段階では、次のような観点が整理されます。

- 採用する技術やアーキテクチャの方向性
- 代替案の比較と選択理由
- 制約条件や前提の整理

Implementation は、Tasks を導き出す前提となる判断をまとめる段階でもあります。
ここで整理された内容が明示されていることで、後続の Tasks がどのような考え方に基づいて構成されているのかを把握しやすくなります。

これらの判断をどのように記録し、参照可能にするかが、次の課題になります。

| 観点   | Implementation | Tasks          |
| ------ | -------------- | -------------- |
| 目的   | 方針を決める   | 作業を実行する |
| 内容   | 判断・選択理由 | 実装・検証単位 |
| 変更時 | DR を残す      | タスクを更新   |
| コード | 書かない       | 書く           |

*表2-2: Implementation と Task の違い*

### 2.6 `Decision Records` で判断を固定する

`deckrd` では、設計の過程で生じる判断を、その場限りのものとして消費しません。
人と AI の対話を通じて行われた判断は、後から参照できる形で固定される必要があります。

Requirements・Specifications・Implementations の各フェーズでは、
前提や判断が繰り返し見直されるため、設計の流れは一方向に進むとは限りません。

その結果、判断の変更や前提の修正がチャットログのなかに埋もれ、
どの案を採用し、どの案を退けたのかを後から追跡しにくくなります。

`deckrd` では、こうした判断を Decision Records（DR）として整理し、記録します。
DR は単なるログではなく、後から設計を説明・再検討するための判断単位として扱われます。

図 2-2 が示しているのは、設計が下流から上流へ「戻る」こと自体ではありません。
重要なのは、その逆流が、その場限りのやり直しとして消費されるのではなく、
Decision Records を介して「どの判断が、どの理由で見直されたのか」という形で固定される点です。

Tasks、Implementations で生じた違和感や矛盾は、
直接 Requirements や Goal を書き換えるのではなく、
いったん DR に集約され、判断として言語化されます。
そのうえで、必要なフェーズに反映されることで、
設計全体の文脈が分断されずに保たれます。

![Decision Records による逆流・判断固定モデル](/images/articles/oss-deckrd/deckrd-flow+dr.png)

*図 2-2: Decision Records による逆流・判断固定モデル*

Decision Records（DR）は、設計の過程で生じた判断を「あとから説明・再検討できる形」で固定するための記録単位です。
コードや仕様そのものを保存するのではなく、**どの案を、どの理由で選び (または捨てたのか)** を残します。
図 2-2 が示す「逆流」を、設計資産として成立させる役割を担います。

| 観点     | DR に記録するもの          | DR に記録しないもの      |
| -------- | -------------------------- | ------------------------ |
| 採用判断 | 採用した設計案と理由       | 採用後の実装コード       |
| 却下判断 | 却下した案と却下理由       | 却下案の詳細設計         |
| 前提変更 | 変更前の前提と変更理由     | 更新後の最新版仕様のみ   |
| 構造判断 | 責務分離・配置・境界の判断 | ディレクトリ構成そのもの |
| 公開範囲 | Public / Internal の線引き | `export` 定義や宣言      |
| 実装方針 | 実装レベルでの最終判断     | 実装手順・How-to         |
| 設計意図 | なぜその判断に至ったか     | どう書いたか             |

*表 2-3: Decision Records（DR）の参考表*

このように、Decision Records を判断の集約点として設けることで、
`deckrd` では設計の見直しが「前提を壊す行為」ではなく、判断を更新する行為として扱われます。

図 2-2 に示されている逆流は、設計が揺れ動く不安定さではなく、判断を固定し直しながら前に進むための構造です。

### 2.7 ドキュメントを鍛えるためのAIとの対話

`deckrd` において、要件定義書や仕様書は完成した成果物ではありません。
AI との対話を通じて検証・更新される、設計検討のための媒体として扱われます。

このときの対話は、次のような観点で行われます。

- Requirements における要求の妥当性確認
- Specifications / Implementations における判断方針の整理
- Tasks における粒度や責務の確認

こうしたやり取りを通じて、
更新されたドキュメントが設計資産として残っていきます。

`deckrd` では、仕様書や Decision Records を通じて判断を固定し、
AI との対話は、ドキュメントを見直し、判断を更新するための工程として位置づけられます。

### 2.8 `deckrd` はタスク作成ツールではない

`deckrd` をタスク作成ツールとして使おうとすると、その価値の大部分を取りこぼすことになります。

Tasks は `deckrd` の最終成果物ではなく、それまでに積み重ねられた判断が、実行可能な形として現れた結果にすぎません。

扱われているのは、Task に至るまでに積み重ねられた思考や判断を、
設計の文脈として整理し、残していく過程です。

この前提では、Tasks は単独で切り出されるものではありません。
Requirements や Specifications、Implementations によって支えられた、設計判断の結果として現れます。

Tasks を辿り直せば、その背後にある判断や前提が見え、さらに遡れば Goal に行き着く関係が保たれます。

実装や技術が変わったとしても、そこで行われた設計上の判断は、別の文脈で再び参照されます。
判断が使い捨てにならず、設計として残り続けるためです。

このような構造を通じて、`deckrd` は、AI による生成結果を一度きりの成果物として消費するのではなく、
設計の思考を積み重ねていく開発の進め方として位置づけられます。

## 3. `deckrd` の仕組みと全体像

`deckrd` は、AI を用いた設計を一時的な対話で終わらせず、判断や前提を設計資産として残すことを目的とした仕組みを持っています。
この章では、deckrd がどのような構造でドキュメントと判断を整理し、全体像を把握できる形にしているのかを概観します。

### 3.1 deckrd が扱うドキュメントの単位

`deckrd` が扱うドキュメントは、保存形式やファイル構成によって区別されるものではありません。
設計の過程で「何を決めるための情報か」という観点から切り分けられた、役割の単位として扱われます。

Goals、Requirements、Specifications、Implementations、Tasks、Decision Records は、いずれも設計に必要な情報ですが、その意味や位置づけは同一ではありません。
それぞれは、設計のどの段階で、どの判断を整理するかという役割に基づいて区別されます。

deckrd では、これらのドキュメントを次のような役割として捉えます。

- Goals：達成したい状態の定義
- Requirements：満たすべき条件の整理
- Specifications：振る舞いと構造の確定
- Implementations：実現方針と判断理由の整理
- Tasks：検証可能な作業単位
- Decision Records：判断と前提の記録

この考え方では、同じ内容であっても、どの役割として置かれるかによって意味が変わります。
未確定の要求と、確定した仕様、検討中の実現方針と、実行対象となる Tasks は、同じ文書に混在させず、それぞれ対応する役割の単位に整理されます。

`deckrd` が管理しているのは、ファイルの集合ではなく、設計判断を置くための論理的な単位です。

この単位が明確であることで、設計のどこで何が決まっているのかが把握しやすくなり、後続のフェーズや見直しの起点も定めやすくなります。

### 3.2 フェーズごとに分離された責務

`deckrd` では、設計を一連の作業としてまとめて扱うのではなく、判断の性質に応じてフェーズを分け、それぞれに異なる責務を与えます。
これは工程管理のためではなく、設計のなかで何を決めているのかを明確にするためです。

設計の途中では、要求の整理、仕様の確定、実現方針の検討、作業単位への分解といった、
性質の異なる判断が連続して現れます。
これらを同じ場所で扱うと、未確定の情報と確定した判断が混在し、
どこまでが検討中で、どこからが前提条件なのかがわかりにくくなります。

`deckrd` は、この混在を避けるために、フェーズごとに責務を分離します。

- Requirements：要求内容の整理
- Specifications：振る舞いと構造の確定
- Implementations：実現方針の検討
- Tasks：作業単位への分解

それぞれのフェーズでは、決めるべき内容が限定されます。
前のフェーズで確定した判断を前提として次につなぎ、未確定の事項は切り分けて扱います。

このように責務を分けて設計を進めることで、判断の前提と結果の関係が整理され、
後から設計を振り返る際にも、どの段階で何が決まったのかを追いやすくなります。

### 3.3 フェーズ間をつなぐ判断の流れ

`deckrd` における設計は、Goals を起点に、Requirements、Specifications、Implementations、Tasks へと判断を引き継ぎながら進みます。
各フェーズで確定した内容は、次のフェーズの前提として用いられます。

一方で、設計は常に一方向に進むとは限りません。
下流の検討を通じて前提の不足や判断の齟齬が見つかり、上流のフェーズに立ち戻って見直す必要が生じることもあります。

`deckrd` では、この行き戻りを例外的な失敗とは扱いません。
Decision Records を通じて、どの判断がどの理由で変更されたのかを記録し、
設計全体の整合性を保ちながら更新していきます。

このため、フェーズ間の判断の流れは次のように整理されます。

- 上流から下流への判断の引き継ぎ
- 下流から上流への見直しと差し戻し
- 一方向に固定しない設計進行

判断の流れを固定しないことで、設計は状況に応じて調整され、無理のない形に収束していきます。
`deckrd` は、この往復を前提とした設計の進行を、ドキュメント構造として支えています。

### 3.4 Decision Records が果たす役割

`deckrd` において、Decision Records（DR）は特定のフェーズに属するドキュメントではありません。
設計の途中で行われた判断や変更を、フェーズに依存せず記録するための単位です。

設計を進める過程では、要件の追加や変更、実現方針の見直しなど、
複数のフェーズをまたぐ判断が発生します。
こうした判断は、1つのフェーズのなかだけでは整理しきれません。

DR は、それらの判断を設計の流れとは独立して残すことで、
どの前提で、どの判断が行われたのかを後から追跡できるようにします。

![論理モデルとしての `deckrd` 全体構造](/images/articles/oss-deckrd/dr.drawio.png)

*図3-1:論理モデルとしての `deckrd` 全体構造*

図 3-1 に示されている構造は、設計の中心にあるのはドキュメントそのものではなく、それらを横断して記録される判断です。

Decision Records をこの位置に据えることで、
`deckrd` は設計を工程や成果物の集合としてではなく、
判断の更新として扱える論理モデルになります。

### 3.5 `deckrd`でのAIの位置づけ

`deckrd` では、AI はドキュメント作成の初期段階と、
作成されたドキュメントを見直し、整理する段階で用いられます。
Requirements、Specifications、Implementations、Tasks の各フェーズで、
ユーザーと AI の対話が、内容を具体化するための補助として組み込まれます。

ただし、設計の内容を決定するのは常にユーザーです。
AI は判断の材料や選択肢を提示し、論点を整理する役割を担いますが、
何を採用し、何を前提とするかを決めることはありません。

ユーザーは、既存のドキュメントを参照しながら AI と対話することで、
要件や仕様への理解を更新し、その理解を次の判断の前提として設計を進めていきます。
このように `deckrd` では、AI を設計を代行する存在とはせず、判断を支えるための確認と整理の補助として位置づけます。

### 3.6 `deckrd`の全体フロー

`deckrd` は、設計を直線的な工程として扱いません。
判断を役割ごとに分け、それらを行き来しながら整理していく流れ全体を、1つの仕組みとして捉えます。

この流れは、次の 3つの側面から構成されます。

1. Goal から Requirements、Tasks へと判断を具体化していく流れ
2. 各フェーズで内容を見直し、前提を更新する流れ
3. 判断や変更を Decision Records として記録する流れ

`deckrd` では、これらを固定された順序として扱いません。
設計の状況に応じて行き来しながら判断を更新し、その過程をドキュメントとして残していきます。

その結果、後から設計を振り返ったときに、
何が前提とされ、どの判断が、どの理由で行われたのかを辿れる状態が保たれます。

## 4. `deckrd` の基本ワークフロー

この章では、`deckrd` を用いて設計を進める際の基本的な流れを概観します。
Goal から Tasks へと至る過程を通じて、「Your Goals to Tasks」という考え方が、どのように具体的な手順として現れるのかを見ていきます。

`deckrd` のワークフローは、操作の順番そのものよりも、各段階でどのドキュメントが、どの判断を担っているかを意識して構成されています。
ドキュメントの作成順序と役割を押さえることで、設計の進行と見直しを無理なく行えるようになります。

### 4.1 ワークフローの全体像

`deckrd` の基本的なワークフローは、
Goal から Tasks へと判断を段階的に具体化していく流れとして整理されています。

1. Goal を言語化する
2. Requirements を整理する
3. Specifications を定義する
4. Implementations を検討する
5. Tasks に落とし込む

![deckrd ワークフロー (操作視点)](/images/articles/oss-deckrd/deckrd-basicflow.png)

*図 4-1: deckrd ワークフロー (操作視点)*

この流れは、設計を一方向に進めるための固定された工程ではありません。
各フェーズの内容はドキュメントとして残され、後続の検討によって前提や判断に修正が必要になった場合には、対応するフェーズへ戻って見直すことができます。

### 4.2 Goal を起点に Requirements を整理する

ワークフローは、設計の対象と目的を明確にするところから始まります。
`deckrd` では、この段階を 2つのコマンドを通じて整理します。

最初に使用する `init` コマンドでは、`<namespace>` と `<module>` を指定し、設計の対象となる範囲と文脈を定めます。
これにより、Goal を考える対象が限定され、どの領域について設計を進めるのかが明確になります。

次に、`req` コマンドで `<title>` を入力します。この `<title>` は、対象とする範囲のなかで何を実現したいのかを示すもので、
Goal を要求として言語化した出発点になります。
`req`は、この内容をもとに要件定義書を作成します。

`<namespace>`、`<module>`、`<title>` を組み合わせて整理された要求をもとに、Requirements を定義していきます。
Requirements は、Goal を要件として具体化したものであり、達成すべき状態や成功とみなす条件を明らかにします。

この段階では、実装方法や技術選択は扱いません。
Requirements は後続のすべての判断の基準となるため、内容と範囲を、関係者間で共有できる形に整理しておくことが重要です。

### 4.3 Requirements を仕様として確定する

次の段階では、Requirements をもとに、仕様としての内容を整理していきます。
ここで扱う Specifications は、Requirements を満たすために必要な振る舞いや条件を、実装から切り離した形で定義したものです。

この段階では、Requirements に含まれていた意図や条件を掘り下げ、何が満たされていれば要件を満たしたと判断できるのかを明確にします。
検討の対象となるのは、次のような観点です。

- 必要とされる振る舞い
- 前提となる制約条件
- 要件を満たす状態の定義

Specifications は、特定の実装方法を前提とせずに記述されます。
そのため、後続の Implementations で複数の実現方針を検討する余地が残されます。

AI との対話は仕様の抜けや解釈の揺れを確認するための補助として用いられ、確定した内容のみが Specifications に反映されます。

### 4.4 実現方針を Implementations として整理する

Specifications が整理された段階で、次に検討するのは、それらをどのような方針で実現するかという点です。
この検討結果をまとめたものが Implementations です。

Implementations では、仕様を満たすための具体的な実現方法を 1つに定めるのではなく、
複数の選択肢を比較しながら、採用する方針とその前提を整理します。
検討の対象となるのは、次のような観点です。

- 採用する技術スタックの候補
- アーキテクチャの方向性
- 実現しない選択肢とその理由

Implementations は、後続の Tasks を導くための前提条件として位置づけられます。
この段階で行われた判断は、状況の変化によって見直されることもありますが、その場合、判断の変更理由は Decision Records として記録されます。

### 4.5 Implementations から Tasks を導く

最後に、Implementations をもとに Tasks を整理します。
ここでは、実現方針としてまとめられていた判断を、実装に着手できる作業単位へと落とし込んでいきます。

`deckrd` では、Tasks の粒度を、ユニットテストにおける 1つのテストケースを基準として考えます。
この基準により、Tasks は実装作業と検証の双方を意識した単位として整理されます。

Tasks が担う意味は、次のように整理できます。

- 実装作業を進めるための単位
- 検証対象となる仕様の表現

こうして作成されたタスクリストは、設計段階で確定した判断を反映した成果物として扱われます。
実装フェーズでは、このタスクリストを前提に作業が進められ、各タスクが実装と検証の起点になります。

### 4.6 `DR` (`Decision Records`) をつかって要件や仕様を修正する

ワークフローの途中で要件や仕様、実現方針の見直しが必要になることがあります。
`deckrd` では、こうした変更を例外的なやり直しとは扱わず、判断に至った理由や背景を DR として記録し、対応するドキュメントに反映します。

`DR` に記録されるのは、どの内容を、どの理由で見直したのかという判断の履歴です。
これにより、修正後のドキュメントだけでなく、そこに至るまでの経緯も含めて把握できるようになります。

この手順は、次のような場面で用いられます。

- 要件の追加や変更に伴う修正
- 仕様の曖昧さや矛盾の解消
- 実現方針の見直しに伴う差し戻し

`DR` を介して修正することで、設計の流れを止めることなく、判断の変更を設計資産として残せます。
ワークフロー全体は、こうした見直しを前提とした循環として維持されます。

### 4.7 ドキュメント主導のワークフロー

`deckrd` のワークフローでは、設計の進行を表すのは操作や対話ではなく、
常に更新され続けるドキュメントです。AI との対話は判断を支える補助であり、設計の前進はドキュメントの更新として表現されます。

このように、設計の進行と履歴がドキュメントに集約されることで、
後から設計を振り返ったり、修正したりする際にも、前提や判断の経緯を追いやすくなります。
`deckrd` は、ドキュメントを軸に据えることで、設計の流れそのものを扱えるワークフローを構成しています。

## 5. SDD と `deckrd` における設計単位の違い

`deckrd` と SDD の関係を理解する際に着目すべき点は、
工程の前後関係ではなく、設計で扱う対象の粒度の違いです。

SDD が、仕様書や要件定義書といった文書全体を設計対象として扱うのに対し、
`deckrd` は、そのなかに含まれる 1つ1つの要件や仕様を、独立した設計単位として整理する枠組みを提供します。

この章では、両者がどの粒度の設計単位を担っているのかを整理し、どのように補完し合う関係にあるのかを見ていきます。

### 5.1 SDDと`deckrd`の設計単位比較

| 観点     | SDD          | deckrd         |
| -------- | ------------ | -------------- |
| 設計単位 | 仕様書全体   | 一要件・一仕様 |
| 粒度     | 粗い         | 細かい         |
| 主目的   | 全体像の共有 | 判断の追跡     |
| 関係     | —            | SDD を補完     |

*表5-1: SDD と deckrd の設計単位比較*

### 5.2 SDD が扱う設計単位

SDD における設計の対象は、個々の要件や仕様ではなく、プロダクトや機能群といったまとまりを単位とした仕様書です。
これらの仕様書は、開発対象の全体像を共有し、実装を進めるための前提を整える役割を担います。

SDD の仕様書には、複数の要件や仕様がまとめて記述されます。各要件や仕様は独立した設計単位として切り出されるというより、
1つの文書のなかで相互に関係づけられながら整理されます。

その結果、SDD が扱う設計単位は、次のような性質を持ちます。

- プロダクトや機能群を対象とした設計単位
- 複数の要件・仕様を束ねた仕様書
- 実装を進めるための包括的な前提

ここで整理しているのは、設計の「粒度」の違いであり、どちらの考え方が優れているかを比較するものではありません。

### 5.3 `deckrd` が扱う設計単位

deckrd が対象とするのは、SDD の仕様書全体ではなく、そのなかに含まれる 1つ1つの要件や仕様です。
要件定義書や仕様書に記載されている内容のうち、個別に検討し、判断の経緯を整理できる単位を設計対象として切り出します。

このとき、deckrd が扱う設計単位は、文書としてのまとまりではなく、設計上の焦点として定義されます。
1つの要件、あるいは 1つの仕様が、それぞれ独立した検討対象となります。

`deckrd` が整理する設計単位は、次のように表せます。

- 要件定義書に含まれる一要件
- 仕様書に含まれる一仕様
- 独立して検討し記録される設計対象

これらの設計単位について、`deckrd` は Requirements、Specifications、Implementations、Tasks という段階を通して整理を進めます。

`deckrd` では、要件や仕様ごとに、
なぜ必要とされたのか、どの範囲を対象とし、
どの仕様・方針で満たし、どのように検証するのかといった判断を、
段階ごとに分けて記録します。

その結果、`deckrd` は一要件・一仕様という粒度で設計の思考過程を扱う枠組みとして位置づけられます。

### 5.4 SDD と `deckrd` の補完関係

設計単位の粒度という観点から見ると、SDD と `deckrd` は、
同じ設計を異なるレベルで扱う補完関係にあります。

SDD は、複数の要件や仕様を束ねた仕様書全体を対象とし、実装を進めるための前提や全体像を整える役割を担います。
一方で `deckrd` は、その仕様書の内部に含まれる一要件・一仕様を取り出し、判断の背景や設計意図を含めて整理します。

- **SDD**
  - 複数の要件・仕様を束ねた仕様書を扱う
  - 実装に向けた全体的な前提を整える
- **`deckrd`**
  - 一要件・一仕様を設計単位として扱う
  - その判断や設計方針を明確にする

`deckrd` は仕様書全体を置き換えるものではなく、SDD の内側にある設計単位を支える枠組みとして機能します。

### 5.5 設計を支える単位としての `deckrd`

`deckrd` は、SDD が扱う仕様書全体を置き換えるものではありません。
その内側にある一要件・一仕様を設計単位として切り出し、判断の背景や設計意図を保持するための枠組みです。

個々の判断を独立した単位として残し、それぞれの仕様を仕様書全体へ結び直せる状態を保つことで、
AI 支援開発においても、設計判断の文脈が断絶しない構造を支えます。

## 6. `deckrd` が力を発揮する活用シーン

この章では、deckrd がどのようなプロジェクトで有効に機能するかを、
設計思想ではなく実際の使われ方の観点から整理します。

| 状況                     | deckrd |
| ------------------------ | ------ |
| 個人開発                 | ◎      |
| 少人数チーム             | ◎      |
| 仕様が頻繁に変わる       | ◎      |
| 大規模ウォーターフォール | △      |
| 完全固定仕様             | △      |

*表6-1: deckrd が向いている / 向いていないケース*

`deckrd` は、大規模プロジェクト向けの重厚な設計フレームワークではありません。
個人開発や小規模開発において、設計と実装を往復しながら前に進むための、軽量なドキュメント設計の仕組みです。

### 6.1 個人開発・少人数開発での設計整理

`deckrd` は、設計と実装を並行して進める個人開発や少人数チームの開発スタイルに適しています。

こうしたプロジェクトでは、要件や仕様を最初から確定させることよりも、作りながら判断し、状況に応じて設計を更新していく進め方が前提になります。

`deckrd` は、1つの Goal や要件・仕様を最小単位として扱うため、大きな仕様書を作らずに、必要な判断だけを記録できます。
その結果、開発のテンポを維持したまま、設計の履歴を積み重ねていけます。

### 6.2 設計が途中で変わることを前提としたプロジェクト

個人開発やアジャイルなプロジェクトでは、次のような状況が自然に発生します。

- 作ってみて初めて要件のズレに気づく
- 技術選定や仕様が途中で変わる
- 設計の正解が最初から見えない

`deckrd` では、Requirements、Specifications、Implementations を分けて扱います。
そのため、変更が生じた場合でも、どの判断を見直すのか、どこから作り直すのかを整理したまま進められます。

設計を壊さずに更新できる点が、試行錯誤を前提とした開発を継続しやすくします。

### 6.3 AI を用いた高速な試行錯誤

`deckrd` は、AI と対話しながら設計を進める使い方を前提としています。
ただし、AI との対話そのものを成果物として残すことは目的にしていません。

AI は、次のような場面で設計を補助します。

- Goal の具体化
- 要件や仕様のレビュー
- 実現方針の選択肢整理

最終的に確定した判断のみをドキュメントとして残すことで、
試行錯誤の速度と、設計判断の再利用性を両立します。

この割り切りにより、短いサイクルで仮説検証を回しながらも、設計判断を失わずに進められます。

### 6.4 SDD を重く感じていたプロジェクト

SDD の考え方に関心はあるものの、次のように感じた経験があるプロジェクトでも `deckrd` は有効です。

- 仕様書を書くコストが高く感じる
- 変更のたびにドキュメントが追いつかない
- 個人開発には過剰に思える

`deckrd` は、SDD の思想を一要件・一仕様という単位まで分解しています。
必要な設計単位だけを取り出して使えるため、マイクロな SDD フレームワークとして無理なく取り入れられます。

### 6.5 速く作り、速く直すための設計補助

`deckrd` は、設計を厳密に管理するためのフレームワークではありません。
試行錯誤のなかで生じる判断や迷いを整理し、作り直しを速くするための補助線を引く仕組みです。

判断の理由を残し、見直す位置を明確にすることで、設計を止めずに更新し続けられる状態を支えます。

## 7. `deckrd`が目指す設計のかたち

`deckrd` は、設計を厳密に管理したり、タスク生成を自動化したりするためのフレームワークではありません。

本稿で見てきたように、`deckrd` が扱っているのは、
Goal から Tasks に至るまでの思考と判断を、設計単位ごとに整理し、ドキュメントとして残すための枠組みです。

設計を最初から固めきらず、
作りながら考え、途中で判断を見直す。
そうした開発の進め方において、
どこで何を考え、なぜその判断に至ったのかを追えることは、
設計の質だけでなく、作り直しの速さにも影響します。

`deckrd` は、
一要件・一仕様という粒度で設計を扱うことで、
判断の前提や変更の影響範囲を見失いにくい構造を提供します。
それは、大きな仕様書を否定するものではなく、その内側を支えるための設計単位の整理です。

個人開発や小規模なプロジェクト、
AI と対話しながら試行錯誤を進める開発において、
考えたことを最小限のコストで残したい。
`deckrd` は、そうした場面で使われることを想定しています。

設計を重くしすぎず、
しかし、思考を流さずに残す。
そのための 1つの選択肢として、`deckrd` を位置づけてもらえれば幸いです。

## おわりに

ここまで、`deckrd` の考え方と使いどころを見てきました。

`deckrd` は、設計を最初から固めきるのではなく、作りながら考え、判断を更新していく開発の進め方を支えるための仕組みです。
要件や仕様を一度きりの成果物として消費せず、考えたことを無理のない形で残すことを目的としています。

試しては作り直すことを前提とした個人開発や OSS 開発では、設計を重くせずに判断の履歴を残せる点が、特に役に立つはずです。

もし、この感覚が自分の開発スタイルに合いそうだと感じたら、気軽に試してみてください。
`deckrd` は、そうした場面で使われることを想定しています。

それでは、Happy Hacking!

## 参考資料

### Webサイト

- deckrd github: <https://github.com/aglabo/deckrd>
  deckrd の GitHub リポジトリ

- README: <https://github.com/aglabo/deckrd/blob/main/plugins/deckrd/README.md>
  deckrd GitHub リポジトリの README
